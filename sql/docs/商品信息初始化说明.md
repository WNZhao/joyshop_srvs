# 商品信息初始化说明

## 概述
为了更好地验证微服务系统的业务逻辑和性能，我们将商品数据量级提升到3000-5000个商品，并确保所有相关数据（库存、订单、分类关联等）都正确关联。

## 数据规模设计

### 商品数据量级
- **总商品数量**: 3500个商品
- **分类分布**: 按现有分类体系均匀分布
- **品牌分布**: 覆盖所有现有品牌，确保数据多样性
- **价格分布**: 涵盖不同价格区间，模拟真实电商场景

### 相关数据关联

#### 1. 商品基础信息 (goods表)
- `id`: 1-3500
- `brand_id`: 关联品牌表
- 商品名称、价格、描述等使用占位符和变体生成
- 图片URL统一使用占位符格式

#### 2. 商品分类关联 (goods_category表)
- 每个商品关联1-3个分类
- 确保主分类和子分类关系正确
- 覆盖所有分类，避免空分类

#### 3. 库存信息 (inventory表)
- 每个商品对应库存记录
- 库存数量：50-500之间随机分布
- 销售数量：0-库存数量*0.3之间
- 冻结数量：0-10之间

#### 4. 订单关联 (order_goods表)
- 生成500-800个测试订单
- 每个订单包含1-5个商品
- 订单商品从3500个商品中随机选择
- 确保订单状态多样化

## 文件结构

```
sql/
├── schemas/
│   ├── 01_users.sql           # 用户数据
│   ├── 02_categories.sql      # 分类数据  
│   ├── 03_brands.sql          # 品牌数据
│   ├── 04_goods.sql           # 商品数据 (扩展到3500个)
│   ├── 05_inventory.sql       # 库存数据 (对应3500个商品)
│   ├── 06_shopping_cart.sql   # 购物车数据
│   ├── 07_orders.sql          # 订单数据 (关联扩展商品)
│   └── 08_banners.sql         # 轮播图数据
└── docs/
    └── 商品信息初始化说明.md   # 本文档
```

## 数据生成策略

### 商品命名规则
```
基础商品名 + 规格变体 + 颜色/尺寸
例如：
- iPhone 15 Pro Max 256GB 深空黑色
- iPhone 15 Pro Max 512GB 深空黑色  
- iPhone 15 Pro Max 256GB 原色钛金属
```

### 价格策略
- **电子数码**: 500-50000元
- **服装鞋帽**: 50-2000元
- **家居家电**: 100-10000元
- **图书文具**: 10-500元
- **美妆护肤**: 50-2000元

### 库存策略
- **热门商品**: 库存200-500，销量较高
- **普通商品**: 库存50-200，销量中等
- **冷门商品**: 库存10-100，销量较低

## 占位符说明

为了便于业务逻辑验证，所有图片URL都使用占位符：

- **商品图片**: `placeholder_image_N.jpg`
- **商品详情图**: `placeholder_desc_N.jpg`
- **商品封面图**: `placeholder_front_N.jpg`
- **品牌Logo**: `placeholder_logo_brandname.png`
- **用户头像**: `placeholder_avatar_username`
- **轮播图**: `placeholder_banner_N.jpg`

## 执行顺序

1. **基础数据**: users, categories, brands
2. **商品数据**: goods (3500条记录)
3. **关联数据**: goods_category (商品分类关联)
4. **库存数据**: inventory (对应3500个商品)
5. **订单数据**: orders, order_goods (关联商品ID 1-3500)
6. **其他数据**: shopping_cart, banners

## 验证要点

### 数据一致性检查
```sql
-- 检查商品总数
SELECT COUNT(*) FROM goods;  -- 应该是3500

-- 检查库存数据完整性  
SELECT COUNT(*) FROM inventory WHERE goods_id <= 3500;  -- 应该是3500

-- 检查分类关联完整性
SELECT COUNT(DISTINCT goods_id) FROM goods_category WHERE goods_id <= 3500;

-- 检查订单商品引用正确性
SELECT COUNT(*) FROM order_goods WHERE goods_id > 3500;  -- 应该是0
```

### 性能测试查询
```sql
-- 分页查询测试
SELECT * FROM goods LIMIT 20 OFFSET 1000;

-- 分类筛选测试  
SELECT g.* FROM goods g 
JOIN goods_category gc ON g.id = gc.goods_id 
WHERE gc.category_id = 111 LIMIT 20;

-- 库存查询测试
SELECT g.name, i.stock FROM goods g 
JOIN inventory i ON g.id = i.goods_id 
WHERE i.stock > 100;
```

## 注意事项

1. **内存使用**: 大量INSERT语句可能占用较多内存
2. **执行时间**: 3500条数据插入需要一定时间
3. **外键约束**: 确保所有关联数据的ID引用正确
4. **索引优化**: 建议在测试前创建必要的索引

## 后续扩展

- 如需更多数据，可以继续扩展到5000-10000个商品
- 可以添加更多商品属性和规格变体
- 可以引入真实图片URL替换占位符
- 可以添加更复杂的订单状态和支付数据